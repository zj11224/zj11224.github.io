<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zj11224.github.io</id>
    <title>ZJ Blog</title>
    <updated>2022-08-10T14:35:37.382Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zj11224.github.io"/>
    <link rel="self" href="https://zj11224.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://zj11224.github.io/images/avatar.png</logo>
    <icon>https://zj11224.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, ZJ Blog</rights>
    <entry>
        <title type="html"><![CDATA[websocket协议]]></title>
        <id>https://zj11224.github.io/post/2022.07.16.websocket协议/</id>
        <link href="https://zj11224.github.io/post/2022.07.16.websocket协议/">
        </link>
        <updated>2022-07-15T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言"><strong>前言</strong></h3>
<p>尝试用刚学的 epoll 封装一个协议，http 协议太复杂，试一下 websocket。</p>
<p>websocket 实现了浏览器和服务器的全双工通信。</p>
<h3 id="开始"><strong>开始</strong></h3>
<h4 id="一-应用场景">一、应用场景</h4>
<p>服务器需要主动发送数据给浏览器的情况下，可以选择 websocket 协议。</p>
<p>但是请注意，该场景下，websocket 并不是唯一选择。</p>
<ul>
<li>网页聊天，即时通讯</li>
<li>弹幕信息</li>
<li>实时推送</li>
</ul>
<h4 id="二-握手阶段">二、握手阶段</h4>
<p>握手阶段是建立在 tcp 已经连接成功的基础上的。</p>
<p>由客户端发送给服务器的握手数据。</p>
<p>其中包含一个用 <strong>base64</strong> 编码的<strong>16</strong>字节的<strong>随机值</strong> key。</p>
<p>服务端收到数据后，返还给客户端，验证数据是否合法。</p>
<p>服务端需要将传过来的 <strong>key</strong> 和 一个固定的 <strong>GUID</strong> 拼接，然后经过 <strong>SHA-1</strong> 加密，再通过 <strong>base64</strong> 编码后返还回去给客户端验证。</p>
<h4 id="三-通信阶段">三、通信阶段</h4>
<p>做自定义协议，几个关键字段：</p>
<ul>
<li>操作码（fin、handshake）</li>
<li>包长度</li>
<li>mask - key</li>
<li>payload data --&gt; json/xml</li>
</ul>
<p>注意 payload len 字段！！！</p>
<ul>
<li>小于等于125，该字段就是有效数据长度</li>
<li>等于 126，后两字节表示有效数据长度</li>
<li>等于 127，后8字节表示有效数据长度</li>
</ul>
<p>这里有博客说，有效数据长度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">2^{7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mn>7</mn><mo>+</mo><mn>16</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{7+16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mn>7</mn><mo>+</mo><mn>64</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{7+64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span><span class="mbin mtight">+</span><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>。</p>
<p>但是实际上有效数据长度应该是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">2^{7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>。</p>
<p>注意：payload len 是和数据长度相关的字段，但它并不就是数据长度！！！</p>
<p>比如 payload len = 127 表示后8位是表示数据长度，127 仍然有其和长度相关的意义。</p>
<p>websocket 协议数据帧上限 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span> ，可以说是长度无限制，理论上也不可能有这么大的数据，传输层也不允许这么大的包。</p>
<h4 id="四-终止阶段">四、终止阶段</h4>
<h4 id="五">五、</h4>
<p>所有的配置到此结束，<strong>再会！！！</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[传输协议]]></title>
        <id>https://zj11224.github.io/post/2022.07.16.传输协议/</id>
        <link href="https://zj11224.github.io/post/2022.07.16.传输协议/">
        </link>
        <updated>2022-07-15T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言"><strong>前言</strong></h3>
<p>主要了解 tcp 和 udp。</p>
<h3 id="开始"><strong>开始</strong></h3>
<h4 id="一-udp">一、udp</h4>
<p>MTU：最大传输单位（网络层限制）。</p>
<p>MSS：最大报文长度（tcp传输层限制）。</p>
<ul>
<li>
<p>udp实际数据长度</p>
<p>udp首部（8字节）+ ip首部（20字节）+ udp实际数据长度 &lt;= MTU（1500字节）</p>
<p>即实际数据长度最大 1472 字节。</p>
<p>但是实际上还存在 pppoe （运营商信息），所以我们一般udp实际数据长度最大 1400 字节。</p>
<p>当然，udp 首部有16位存储长度，理论上最大长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>，而且到 IP 层太大也会分片。</p>
<p>但是，这只是理论上的，实际使用过程中，当 sendto 超过 MTU，会报错。</p>
</li>
</ul>
<p>可靠性传输</p>
<ul>
<li>ACK机制</li>
<li>重传机制</li>
<li>序号机制</li>
<li>重排机制</li>
<li>窗口机制</li>
</ul>
<p>主要用途：</p>
<ul>
<li>大量数据传输（下载）</li>
<li>实时性强（竞技类游戏）</li>
<li>已有的协议（dns 请求域名 ip）</li>
</ul>
<p>缺点：</p>
<ul>
<li>不稳定</li>
<li></li>
</ul>
<h4 id="二-tcp">二、TCP</h4>
<h4 id="三">三、</h4>
<h4 id="四">四、</h4>
<h4 id="五">五、</h4>
<p><strong>再会！！！</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网络编程]]></title>
        <id>https://zj11224.github.io/post/2022.07.10.网络编程/</id>
        <link href="https://zj11224.github.io/post/2022.07.10.网络编程/">
        </link>
        <updated>2022-07-09T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言"><strong>前言</strong></h3>
<p>堵塞IO：没有数据时堵塞，直到数据返还。</p>
<p>非堵塞IO：没有数据时返还 err，有数据时返还数据。</p>
<h3 id="开始"><strong>开始</strong></h3>
<h4 id="一-socket">一、socket</h4>
<p>关键词：socket通信；socketfd；fd；io；</p>
<ul>
<li>socket 是什么？
<ol>
<li>数字</li>
<li>文件</li>
<li>文件描述符</li>
<li>fd</li>
</ol>
</li>
</ul>
<p>以上理解都是对的，socket 本质上就是插座，为 tcp 通信提供具体的接口。</p>
<ul>
<li>fd是什么？</li>
</ul>
<p>socket() 函数创建一个 socketfd。</p>
<p>注意：fd 本质上就是位图上的一位数字，从小到大创建。</p>
<p>fd 可以看作是<strong>网络资源数值化</strong>的结果（五元组：源ip、目的ip、源端口、目的端口、协议）。</p>
<p>fd --&gt; （sip, dip, sport, dport, tcp/udp)。</p>
<p>可以将其当作一个客户端，同时具备一些 io 的属性。</p>
<p>每个进程都有自己的文件系统空间，即 fd 都是内部分配，两个不同进程可能存在相同 fd，但是具体的含义是一样的，父子进程是可以继承 fd 的，即自己进程空间中都有一个fd，但是指向内核文件都是同一个，被记录在open files table这个表中，每个内核连接文件都有自己的send、revc buffer（内核态中）。</p>
<p><code>ulimit -a</code> 可查看进程fd上限（open file）。</p>
<ul>
<li>io 是什么？</li>
</ul>
<p>内存（cpu）与外存、外设、内存以外通信都需要经过 io。</p>
<p>内存与磁盘、网卡通信也是需要经过 io的。</p>
<h4 id="二-sigio">二、sigio</h4>
<p>关键词：sigio；协议栈；信号；进程信号；系统调用；</p>
<p>为什么要了解 sigio 呢，这里涉及内核态的信号和回调机制。</p>
<p>我们想像一下一个场景，客户端发送一个消息到服务器指定端口，首先由操作系统接收，然后操作系统通知进程，即将信号抛给进程，进程捕获到 sigio 信号，才能正常接收数据。</p>
<p>比如 epoll_wait() 堵塞唤醒，就是因为收到了某个信号值。</p>
<p>sigio 没有区分是哪个 fd。<br>
udp 接收一个包，触发一次 sigio。<br>
tcp 不可以这样，因为包太多了，处理的 sigio 会很多。<br>
在协议栈中，控制 tcp 不去发 sigio。</p>
<ul>
<li>
<p>进程的信号集怎么保存？</p>
<p>每个进程都有用户态和内核态。</p>
<p>进程内核态中有一块专门的空间用来存信号，总共有 31 种信号。</p>
<p>sched.h -&gt; task_struct -&gt; sighand_struct -&gt; k_sigaction action[_NSIG]；</p>
<p>其中 _NSIG = 64，表示信号存在 action[64] 中。</p>
</li>
<li>
<p>调用 signal 函数时，信号怎么保存到进程中？</p>
<p>比如，<code>kill -9 pid</code> 就是调用可执行文件 kill，然后调用系统函数 kill() 发送信号给对应进程。</p>
<p>然后对应进程通过更改 action[sig - 1] 进行保存。</p>
<p>上一个 sigio 没有触发的会被覆盖。</p>
<p>本质</p>
</li>
<li>
<p>信号如何发送的？</p>
<p>通过调用系统函数向进程发送信号。</p>
</li>
</ul>
<h4 id="三-select">三、select</h4>
<p><code>select(fd_num，rdfs, wdfs, edfs, time_out)</code></p>
<p>select 为了实现 io 多路复用，采取<strong>条件等待</strong>的方式，当有事件触发时，逐个询问，当前 fd 有事件触发，先将 fd 存放数组当中，轮询完毕后，再处理这些事件。</p>
<p>rdfs、wdfs、edfs 在调用 select 前，需要设置成我们关心的对应 dfsets，select 返还时会重置三个 set，将就绪 fd 放入其中，因此每次调用前，都需要重置我们关心的 fd。</p>
<p><code>time_out</code> 当没有事件触发，定时器倒计时完毕，也会激活 select。</p>
<ul>
<li>
<p>监听 fd 数量限制</p>
<p>由宏定义 FD_SETS 定义，即可使用 fd 最多数量，本质就是 bitmap 大小。</p>
<p><code>cat /proc/sys/fs/file-max</code> 可查看最大 fd 数量。</p>
<p>可以修改，但是可能会影响性能。</p>
</li>
<li>
<p>采用线性扫描，效率较低</p>
<p>调用时间复杂度是线性的，即O(n)。</p>
<p>只知道有 IO 事件发生，却<strong>不知道具体是谁</strong>，无差别询问所有流。</p>
</li>
<li>
<p>用户态数据拷贝到内核态</p>
<p>每次 select 都需要将 rdfs、wdfs、edfs 从用户态拷贝到内核态。</p>
<p>当 df 很多时，这个数据量会很大。</p>
</li>
</ul>
<p>当 socket 较多时，每次都要遍历 FD_SIZE 个 socket， 会浪费很多 CPU 时间。</p>
<p>如果能给 socket 注册对应回调函数，当他们活跃时，自动完成相关操作，即可避免轮询。</p>
<p>这种机制就是后文要说的 epoll。</p>
<p>注意：select 并不是<strong>轮询</strong>机制？</p>
<h4 id="四-poll">四、poll</h4>
<p>select 中 read、write、end 三种事件，三个参数。</p>
<p>poll 中 将其合并，只用一个参数存储，仅此而已。</p>
<h4 id="五-epoll">五、epoll</h4>
<p>epoll 实现类似于被触发的事件存放在一个地方，然后通过 epoll_wait 函数取出被触发的事件，然后执行相应操作。</p>
<p><code>epoll_create(int size)</code></p>
<p>早期 size 表示就绪队列大小，现在只有 0 和 1 的区别。</p>
<p><code>epoll_wait(epfd, events, length, timeout)</code></p>
<p><code>timeout</code>：定期取出，-1 表示有数据才取。</p>
<p><code>length</code>：每次取出的数量，建议总 io 的 100 分之 1。</p>
<p><code>epoll_ctl(int epfd, int op, int fd, struct epoll_event* event)</code></p>
<p><code>fd</code>：监听 fd。</p>
<p>epoll_ctl做了两件事情：</p>
<ul>
<li>事件注册在红黑树（socketfd 作为 key）。</li>
<li>和网卡驱动程序建立一个回调关系，检测到有事件发生，拷贝到就绪队列当中。</li>
</ul>
<p>被动连接（作为服务器），事件注册为EPOLLIN，第一次触发表示连接成功。</p>
<p>主动连接（作为客户端），事件注册为EPOLLIOUT，第一次触发（第二次握手）表示连接成功。</p>
<p>ET（边沿触发）：缓冲区状态变化（增、减）触发</p>
<p>LT（水平触发）：有数据一直触发</p>
<p>ET + 循环读（触发一次循环读取完）</p>
<p>LT + 一次读（多次触发读取完毕）</p>
<p>本质上都是一样的，多次读，但是ET是针对一个IO循环读，没有兼顾其他IO，所以建议用来处理小块数据。</p>
<p>ET必须使用非阻塞IO。<br>
因为ET是缓冲区变化才触发，需要循环读，直到读取不到数据才停止，而堵塞io会导致最后一次读取堵塞，无法结束。</p>
<p>listenfd适合LT，防止丢失连接请求。</p>
<p>epoll_wait会切换到内核态。</p>
<p>epoll_wait 一次只能触发一个 listenfd，即取出来的 n 个事务，只有一个事务是关于 listenfd 的，只能连接一个客户端。<br>
当出现大量客户端请求连接时，比如100个，那么 epoll_wait 需要触发100次，才能将这些连接事务处理完毕，但是每处理一个连接事务都要处理 n - 1 个其他事务，导致连接效率低下。</p>
<p>多线程，但是可能出现以下情况：</p>
<p>客户端在线程A中存在运行数据，然后后面在线程B中运行，这样就会导致一些数据竞争的问题，这里要求线程只处理数据，不存数据。</p>
<p><strong>BUGS：</strong><br>
在Linux内核版本2.6.9之前，EPOLL_CTL_DEL操作时，event必须是一个非空的指针，实际并没有使用。</p>
<p>2.6.9内核版本以后可以直接设置为NULL。</p>
<p>io多路复用：单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力。</p>
<p>reactor模型：对io的处理改为对事件的处理，通过事件驱动或事件回调的方式来实现驱动模型。</p>
<p>握手和挥手都是协议栈处理的，io读写通道的关闭会影响协议栈消息的发出（关闭前发送消息，内部有很多状态）。</p>
<p>tcp keeplive检测只是在传输层，应用层的死锁和堵塞它是无法识别的，所以需要应用层的心跳检测。</p>
<p>每个reactor都有一个独立的epoll对象。</p>
<h4 id="六-websocket">六、websocket</h4>
<p>websocket和http都是建立在tcp连接（三次握手）之后，即是在send、revc中操作。</p>
<h4 id="七-百万并发">七、百万并发</h4>
<p>服务器单个端口监听情况下，客户端上限3w个连接，原因是客户端可用端口限制导致fd数量限制（port_range_from) 。</p>
<p>服务器多个端口监听情况下，客户端上限6w5个连接，原因是被协议栈出去的防火墙netfilter阻拦（/etc/sysctl.conf, nf_conntrack_max)</p>
<p><strong>再会！！！</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[设计模式]]></title>
        <id>https://zj11224.github.io/post/2022.07.09.设计模式/</id>
        <link href="https://zj11224.github.io/post/2022.07.09.设计模式/">
        </link>
        <updated>2022-07-08T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言"><strong>前言</strong></h3>
<p>​	设计模式是指在软件开发中，经过验证的，用于解决在特定环境下，重复出现的，特定问题的解决方案。</p>
<p>​	下面将大体介绍所有的设计模式。</p>
<h3 id="开始"><strong>开始</strong></h3>
<h5 id="模式设计原则">模式设计原则</h5>
<ol>
<li>依赖倒置原则
<ul>
<li>高层模块不应该依赖底层模块，二者都应该依赖<strong>抽象</strong>；</li>
<li>抽象不应该依赖具体实现，具体实现应该依赖于<strong>抽象</strong>；</li>
</ul>
</li>
<li>开放封闭原则
<ul>
<li>一个类应该对扩展开放，对修改关闭；</li>
</ul>
</li>
<li>面向接口编程
<ul>
<li>不将变量类型声明为莫格具体的类，而是声明为某个接口；</li>
<li>客户程序无需获取对象的具体类型，只需要知道对象所具有的接口；</li>
<li>减少系统中各部分的依赖关系，从而实现 “高内聚、松耦合”的类型设计方案；</li>
</ul>
</li>
<li>封装变化点
<ul>
<li>将<strong>稳定点</strong>和<strong>变化点</strong>分离，扩展修改变化的，让稳定点与变化点实现层次分离；</li>
</ul>
</li>
<li>单一职责原则
<ul>
<li>一个类应该仅有一个引起它变化的原因；</li>
</ul>
</li>
<li>里氏替换原则
<ul>
<li>子类型必须能替换掉它的父类型；</li>
<li>主要出现在子类覆盖父类实现，原来使用父类型的程序可能出现错误；</li>
<li>覆盖了父类方法却没实现父类方法的<strong>职责</strong>；</li>
</ul>
</li>
<li>接口隔离原则
<ul>
<li>不应该强迫客户依赖于他们不用的方法；</li>
<li>一般用于处理一个类拥有比较多的接口，而这些接口涉及很多职责；</li>
</ul>
</li>
<li>对象组合优于类继承
<ul>
<li>继承耦合度高，组合耦合度低；</li>
</ul>
</li>
</ol>
<h4 id="一-模板方法">一、模板方法</h4>
<p>通过算法骨架<strong>约束</strong>子类行为。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

class ZooShow {
public:
    // 固定流程封装到这里
    void Show() {
        Show0();
        Show1();
        Show2();
        Show3();
    }
protected:
    // 子流程 使用protected保护起来 不被客户调用 但允许子类扩展
    virtual void Show0(){
        cout &lt;&lt; &quot;show0&quot; &lt;&lt; endl;
    }
    virtual void Show2(){
        cout &lt;&lt; &quot;show2&quot; &lt;&lt; endl;
    }
    virtual void Show1() {

    }
    virtual void Show3() {

    }
};
class ZooShowEx : public ZooShow {
protected:
    virtual void Show1(){
        cout &lt;&lt; &quot;show1&quot; &lt;&lt; endl;
    }
    virtual void Show3(){
        cout &lt;&lt; &quot;show3&quot; &lt;&lt; endl;
    }
    virtual void Show4() {
        //
    }
};

class ZooShowEx1 : public ZooShow {
protected:
    virtual void Show0(){
        cout &lt;&lt; &quot;show1&quot; &lt;&lt; endl;
    }
    virtual void Show2(){
        cout &lt;&lt; &quot;show3&quot; &lt;&lt; endl;
    }
};

class ZooShowEx2 : public ZooShow {
protected:
    virtual void Show1(){
        cout &lt;&lt; &quot;show1&quot; &lt;&lt; endl;
    }
    virtual void Show2(){
        cout &lt;&lt; &quot;show3&quot; &lt;&lt; endl;
    }
};
/*
依赖倒置原则
单一职责原则
接口隔离原则

反向控制：应用程序 框架 应用程序（变化的）应该依赖框架（稳定的），应该是框架去调应用程序，而不是应用程序去调框架
*/
int main () {
    ZooShow *zs = new ZooShowEx;
    ZooShow *zs1 = new ZooShowEx1;
    ZooShow *zs2 = new ZooShowEx2;
    zs-&gt;Show();
    return 0;
}
</code></pre>
<h4 id="二-观察者模式">二、观察者模式</h4>
<p><strong>触发</strong>联动。</p>
<pre><code class="language-c++">#include &lt;vector&gt;

class IDisplay {
public:
    virtual void Show(float temperature) = 0;
    virtual ~IDisplay() {}
};

class DisplayA : public IDisplay {
public:
    virtual void Show(float temperature);
};

class DisplayB : public IDisplay{
public:
    virtual void Show(float temperature);
};

class WeatherData {
};

class DataCenter {
public:
    void Attach(IDisplay * ob);
    void Detach(IDisplay * ob);
    void Notify() {
        float temper = CalcTemperature();
        for (auto iter = obs.begin(); iter != obs.end(); iter++) {
            (*iter)-&gt;Show(temper);
        }
    }

private:
    virtual WeatherData * GetWeatherData();

    virtual float CalcTemperature() {
        WeatherData * data = GetWeatherData();
        // ...
        float temper/* = */;
        return temper;
    }
    std::vector&lt;IDisplay*&gt; obs;
};

int main() {
    DataCenter *center = new DataCenter;
    IDisplay *da = new DisplayA();
    IDisplay *db = new DisplayB();
    center-&gt;Attach(da);
    center-&gt;Attach(db);
    center-&gt;Notify();
    
    //-----
    center-&gt;Detach(db);
    center-&gt;Notify();
    return 0;
}
</code></pre>
<h4 id="三-策略模式">三、策略模式</h4>
<p>分离算法，选择实现。</p>
<pre><code class="language-c++">class Context {

};

class ProStategy {
public:
    virtual double CalcPro(const Context &amp;ctx) = 0;
    virtual ~ProStategy();
};
// cpp
class VAC_Spring : public ProStategy {
public:
    virtual double CalcPro(const Context &amp;ctx){}
};
// cpp
class VAC_QiXi : public ProStategy {
public:
    virtual double CalcPro(const Context &amp;ctx){}
};
class VAC_QiXi1  : public VAC_QiXi {
public:
    virtual double CalcPro(const Context &amp;ctx){}
};
// cpp
class VAC_Wuyi : public ProStategy {
public:
    virtual double CalcPro(const Context &amp;ctx){}
};
// cpp
class VAC_GuoQing : public ProStategy {
public:
    virtual double CalcPro(const Context &amp;ctx){}
};

class VAC_Shengdan : public ProStategy {
public:
    virtual double CalcPro(const Context &amp;ctx){}
};

// 稳定的  变化的
class Promotion {
public:
    Promotion(ProStategy *sss) : s(sss){}
    ~Promotion(){}
    double CalcPromotion(const Context &amp;ctx){
        return s-&gt;CalcPro(ctx);
    }
private:
    ProStategy *s;
};

int main () {
    Context ctx;
    ProStategy *s = new VAC_QiXi1();
    Promotion *p = new Promotion(s);
    p-&gt;CalcPromotion(ctx);
    return 0;
}
</code></pre>
<h4 id="四-责任链模式">四、责任链模式</h4>
<p>分离职责，动态组合。</p>
<pre><code class="language-c++">#include &lt;string&gt;

class Context {
public:
    std::string name;
    int day;
};


class IHandler {
public:
    virtual ~IHandler() {}
    void SetNextHandler(IHandler *next) {
        next = next;
    }
    bool Handle(ctx) {
        if (CanHandle(ctx)) {
            return HandleRequest();
        } else if (GetNextHandler()) {
            return GetNextHandler()-&gt;HandleRequest(ctx);
        } else {
            // err
        }
    }
protected:
    virtual bool HandleRequest(const Context &amp;ctx) = 0;
    virtual bool CanHandle(const Context &amp;ctx) =0;
    IHandler * GetNextHandler() {
        return next;
    }
private:
    IHandler *next;
};

class HandleByMainProgram : public IHandler {
protected:
    virtual bool HandleRequest(const Context &amp;ctx){
        //
    }
    virtual bool CanHandle() {
        //
    }
};

class HandleByProjMgr : public IHandler {
protected:
    virtual bool HandleRequest(const Context &amp;ctx){
        //
    }
    virtual bool CanHandle() {
        //
    }
};
class HandleByBoss : public IHandler {
public:
    virtual bool HandleRequest(const Context &amp;ctx){
        //
    }
protected:
    virtual bool CanHandle() {
        //
    }
};

int main () {
    IHandler * h1 = new MainProgram();
    IHandler * h2 = new HandleByProjMgr();
    IHandler * h3 = new HandleByBoss();
    h1-&gt;SetNextHandler(h2);
    h2-&gt;SetNextHandler(h3);
    Context ctx;
    h1-&gt;handle(ctx);
    return 0;
}
</code></pre>
<h4 id="五-装饰器模式">五、装饰器模式</h4>
<p>动态组合。</p>
<pre><code class="language-c++">// 普通员工有销售奖金，累计奖金，部门经理除此之外还有团队奖金；后面可能会添加环比增长奖金，同时可能产生不同的奖金组合；
// 销售奖金 = 当月销售额 * 4%
// 累计奖金 = 总的回款额 * 0.2%
// 部门奖金 = 团队销售额 * 1%
// 环比奖金 = (当月销售额-上月销售额) * 1%
// 销售后面的参数可能会调整
class Context {
public:
    bool isMgr;
    // User user;
    // double groupsale;
};

// 试着从职责出发，将职责抽象出来
class CalcBonus {    
public:
    CalcBonus(CalcBonus * c = nullptr) {}
    virtual double Calc(Context &amp;ctx) {
        return 0.0; // 基本工资
    }
    virtual ~CalcBonus() {}

protected:
    CalcBonus* cc;
};

class CalcMonthBonus : public CalcBonus {
public:
    CalcMonthBonus(CalcBonus * c) : cc(c) {}
    virtual double Calc(Context &amp;ctx) {
        double mbonus /*= 计算流程忽略*/; 
        return mbonus + cc-&gt;Calc(ctx);
    }
};

class CalcSumBonus : public CalcBonus {
public:
    CalcSumBonus(CalcBonus * c) : cc(c) {}
    virtual double Calc(Context &amp;ctx) {
        double sbonus /*= 计算流程忽略*/; 
        return sbonus + cc-&gt;Calc(ctx);
    }
};

class CalcGroupBonus : public CalcBonus {
public:
    CalcGroupBonus(CalcBonus * c) : cc(c) {}
    virtual double Calc(Context &amp;ctx) {
        double gbnonus /*= 计算流程忽略*/; 
        return gbnonus + cc-&gt;Calc(ctx);
    }
};

class CalcCycleBonus : public CalcBonus {
public:
    CalcGroupBonus(CalcBonus * c) : cc(c) {}
    virtual double Calc(Context &amp;ctx) {
        double gbnonus /*= 计算流程忽略*/; 
        return gbnonus + cc-&gt;Calc(ctx);
    }
};

int main() {
    // 1. 普通员工
    Context ctx1;
    CalcBonus *base = new CalcBonus();
    CalcBonus *cb1 = new CalcMonthBonus(base);
    CalcBonus *cb2 = new CalcSumBonus(cb1);
    cb2-&gt;Calc(ctx1);
    // 2. 部门经理
    Context ctx2;
    CalcBonus *cb3 = new CalcGroupBonus(cb2);
    cb3-&gt;Calc(ctx2);
}
</code></pre>
<h4 id="六-单例模式">六、单例模式</h4>
<p>一个类仅有一个实例。</p>
<pre><code class="language-c++">// 不考虑继承
// c++11 magic static 特性：如果当变量在初始化的时候，并发同时进⼊声明语句，并发
线程将会阻塞等待初始化结束。
class Singleton
{
    public:
    ~Singleton(){}
    static Singleton&amp; GetInstance() {
        static Singleton instance;
        return instance;
    }
    private:
    Singleton(){}
    Singleton(const Singleton&amp;) {}
    Singleton&amp; operator=(const Singleton&amp;) {}
};
// g++ Singleton.cpp -o singleton -std=c++11
/*该版本具备 版本5 所有优点：
1. 利⽤静态局部变量特性，延迟加载；
2. 利⽤静态局部变量特性，系统⾃动回收内存，⾃动调⽤析构函数；
3. 静态局部变量初始化时，没有 new 操作带来的cpu指令reorder操作；
4. c++11 静态局部变量初始化时，具备线程安全；
*/
</code></pre>
<pre><code class="language-c++">// 加上模板和继承情况
template&lt;typename T&gt;
class Singleton {
    public:
    static T&amp; GetInstance() {
        static T instance; // 这⾥要初始化DesignPattern，需要调⽤
        DesignPattern 构造函数，同时会调⽤⽗类的构造函数。
            return instance;
    }
    protected:
    virtual ~Singleton() {}
    Singleton() {} // protected修饰构造函数，才能让别⼈继承
    Singleton(const Singleton&amp;) {}
    Singleton&amp; operator =(const Singleton&amp;) {}
};
class DesignPattern : public Singleton&lt;DesignPattern&gt; {
    friend class Singleton&lt;DesignPattern&gt;; // friend 能让 Singleton&lt;T&gt; 访
    问到 DesignPattern构造函数
        private:
    DesignPattern(){}
    DesignPattern(const DesignPattern&amp;) {}
    DesignPattern&amp; operator=(const DesignPattern&amp;) {}
}
</code></pre>
<p>所有的配置到此结束，<strong>再会！！！</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[布隆过滤器]]></title>
        <id>https://zj11224.github.io/post/2022.07.08.布隆过滤器/</id>
        <link href="https://zj11224.github.io/post/2022.07.08.布隆过滤器/">
        </link>
        <updated>2022-07-07T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言"><strong>前言</strong></h3>
<p>布隆过滤器就是 hash + bitmap。</p>
<h3 id="开始"><strong>开始</strong></h3>
<h4 id="一-背景">一、背景</h4>
<h5 id="1-使用场景">1、使用场景</h5>
<ul>
<li>使用 word 文档时，word 如何判断某个单词是否拼写正确？</li>
<li>网络爬虫程序，如何不再爬取相同url页面？允许有误差</li>
<li>垃圾邮件（短信）过滤算法如何实现？允许有误差</li>
<li>公安办案时，如何判断嫌疑人是否在网逃名单？控制误差 假阳率</li>
<li>缓存穿透问题如何解决？允许有误差</li>
</ul>
<h5 id="2-缓存穿透">2、缓存穿透</h5>
<p>缓存数据库：redis；</p>
<p>落盘数据库：mysql；</p>
<p>为了减轻落盘数据库的访问压力，在服务端和数据库之间加入一层用来存放热点数据的缓冲数据层。</p>
<p>这个体系数据<strong>请求流程：</strong></p>
<ol>
<li>访问 redis，如果存在，直接返回；如果不存在跳到2；</li>
<li>访问 mysql，如果不存在，直接返回；如果存在跳到3；</li>
<li>将 mysql 存在的 key <strong>写回</strong> redis;</li>
</ol>
<p>黑客利用漏洞伪造数据攻击或者内部业务bug重复大量请求不存在的数据。</p>
<p>那么当一直查询在 redis 和 mysql <strong>都不存在</strong>的数据时，每次一请求都会访问到 mysql，导致其<strong>压力过大</strong>，这就是缓存穿透。</p>
<p><strong>解决办法：</strong></p>
<ol>
<li>
<p>对于 mysql 中不存在的 key，在 redis 端设置 &lt;key, null&gt; 键值对，以此避免访问 mysql；</p>
<p>缺点是 &lt;key, null&gt; 过多时，占用过多内存；</p>
<p>可以给 key 设置过期时间，redis 会自动清除无用的 key；</p>
</li>
<li>
<p>在 server 端存储一个布隆过滤器，将 mysql 中存在的 key 放入布隆过滤器中；</p>
<p>布隆过滤器一定能过滤掉不存在的数据；</p>
</li>
</ol>
<h4 id="二-hash函数">二、hash函数</h4>
<p>本质上就是将一个数据映射成一个数字，将这个数据和数字画上等号。</p>
<pre><code class="language-c++">// 一个简单的哈希函数
const int C = 13331;
unsigned int getHash(char* s) {
    unsigned int res = 0;
	for (int i = 0; s[i]; i += 1) {
		res = res * C + s[i];
    }
    return res;
}
</code></pre>
<p>可能存在不同数据经过哈希被映射成相同数值，这种情况就称为哈希冲突。</p>
<p>这里有两种hash冲突解决方案：</p>
<ul>
<li>
<p>链表法</p>
<p>若出现哈希冲突，将后面冲突 key 添加到 原有 key 的尾端。</p>
<p>即对每个哈希值建立一条链表来存储哈希冲突的 key。</p>
<p>当冲突元素过多，导致链表过长时，可以将其转化为红黑树，临界值一般是（256）。</p>
<p>java中hash相关容器就是上述方法实现。</p>
</li>
<li>
<p>开放寻址法</p>
<p>若出现哈希冲突，将后面冲突 key 按照一定规律寻找其他位置是否能放入。</p>
<p>规律大概有以下两种：</p>
<ol>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo>+</mo><mn>2</mn><mo separator="true">,</mo><mi>i</mi><mo>+</mo><mn>3</mn><mo separator="true">,</mo><mi>i</mi><mo>+</mo><mn>4</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">i+1,i+2,i+3,i+4,...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><msup><mn>1</mn><mn>2</mn></msup><mo separator="true">,</mo><mi>i</mi><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup><mo separator="true">,</mo><mi>i</mi><mo>−</mo><msup><mn>3</mn><mn>2</mn></msup><mo separator="true">,</mo><mn>1</mn><mo>+</mo><msup><mn>4</mn><mn>2</mn></msup><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">i-1^2,i+2^2,i-3^2,1+4^2,...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">4</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span></li>
</ol>
<p>但是注意，这两种插入规律都会导致<strong>同类hash聚集</strong>，即近似值的哈希值也近似，那么他们位置也靠近，形成 hash 聚集。</p>
<p>只不过第一种聚集冲突在前，第二种聚集冲突延后。</p>
<p>我们可以通过<strong>双重哈希</strong>来解决 hash 聚集现象</p>
<p>具体原理：https://www.cnblogs.com/organic/p/6283476.html</p>
</li>
</ul>
<h4 id="三-位图">三、位图</h4>
<p>位图（bitmap）：即一位代表一个数字是否存在。</p>
<p>如一个char变量具有8bit，那么它能表示 0 ~ 7 是否存在；</p>
<p>增加一个char，就能增加 8 ~ 15 表示范围。</p>
<pre><code class="language-c++">unsigned char bitmap[];
// 除法和取余都对应当前数组数据类型 bit 数
// unsigned char -- 8
// unsigned int -- 32
void setBit(int x) {
	bitmap[x / 8] |= (1 &lt;&lt; (x % 8));
}
bool getBit(int x) {
    int res = bitmap[x / 8] &amp; (1 &lt;&lt; (x % 8));
    return res != 0;
}
</code></pre>
<h4 id="四-布隆过滤器">四、布隆过滤器</h4>
<p>注意，上面的 hash 算法都需要存储源数据本身。</p>
<p>当存储海量数据时，无法提供几百G的内存。</p>
<p>因此我们需要一个具有哈希算法优点--<strong>不需要比较</strong>，且摒弃缺点--<strong>存储key</strong>的数据结构，那就是布隆过滤器。</p>
<p>通过<strong>双重哈希算法</strong>和<strong>位图</strong>来实现以上想法。</p>
<p>布隆过滤器是一种<strong>概率型</strong>数据结构，特点是高效的<strong>插入</strong>和<strong>查询</strong>，能明确告知数据<strong>一定不存在</strong>或者<strong>可能存在</strong>。</p>
<p>仍然有缺点：<strong>无法删除</strong>，返还结果具有<strong>概率性</strong>，即结果<strong>存在误差</strong>，但<strong>误差可控</strong>。</p>
<p>我们可以构造出 k 个 hash 函数，然后通过 k 个 hash 函数获得 k 个 hash 值。</p>
<p>插入时，将这 k 个 hash 值存在 bitmap 对应位置。</p>
<p>查询时，看 bitmap 中这 k 个位置是否都为 1。</p>
<pre><code class="language-c++">n -- 布隆过滤器中元素的个数，如上图 只有str1和str2 两个元素 那么 n=2
p -- 假阳率，在0-1之间 0.000000
m -- 位图所占空间
k -- hash函数的个数
公式如下：
n = ceil(m / (-k / log(1 - exp(log(p) / k))))
p = pow(1 - exp(-k / (m / n)), k)
m = ceil((n * log(p)) / log(1 / pow(2, log(2))));
k = round((m / n) * log(2));
</code></pre>
<ul>
<li>
<p>在实际应用中，我们确定 n 和 p，通过上⾯的计算算出 m 和 k；</p>
<p>也可以在网站上选取合适的值： https://hur.st/bloomfilter</p>
</li>
<li>
<p>如何选取 k 个 hash 函数</p>
<pre><code class="language-c++">// 采⽤⼀个hash函数，给hash传不同的种⼦偏移值
// #define MIX_UINT64(v) ((uint32_t)((v&gt;&gt;32)^(v)))
uint64_t hash1 = MurmurHash2_x64(key, len, Seed);
uint64_t hash2 = MurmurHash2_x64(key, len, MIX_UINT64(hash1));
for (i = 0; i &lt; k; i++) // k 是hash函数的个数
{
 Pos[i] = (hash1 + i*hash2) % m; // m 是位图的⼤⼩
}
// 通过这种⽅式来模拟k个hash函数 跟我们前⾯开放寻址法 双重hash是⼀样的思路
</code></pre>
</li>
</ul>
<p><strong>再会！！！</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[红黑树]]></title>
        <id>https://zj11224.github.io/post/2022.07.07.红黑树/</id>
        <link href="https://zj11224.github.io/post/2022.07.07.红黑树/">
        </link>
        <updated>2022-07-06T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言"><strong>前言</strong></h3>
<p>​	红黑树真的好难啊，不想学了！！！</p>
<p>​	基本照着网上博客抄了一遍，基本上原理懂了。</p>
<p>​	红黑树和B/B+树本质上都是2-3-4树的变种，通过上升和下沉操作来保持平衡，只不过在红黑树中上升和下沉都是通过左旋和右旋实现。</p>
<p>​	set和map都是红黑树实现，但是 set 只存 key，map 存 &lt;key, value&gt;，同时会使用覆盖（相同 key， value选择后面的）。</p>
<h3 id="开始"><strong>开始</strong></h3>
<h4 id="一-定义">一、定义</h4>
<ol>
<li>每个结点是红的或者黑的；</li>
<li>根结点是黑的；</li>
<li>每个叶子结点是黑的；</li>
<li>如果一个结点是红的，则它的两个儿子都是黑的；</li>
<li>对每个结点，从该结点到其子孙结点的所有路径上的 包含相同数目的黑结点。</li>
</ol>
<p>红黑树是一颗非严格平衡二叉树</p>
<p>如黑色高度为h，那么该红黑树每条链的长度在 h 到 2 * h - 1 之间。</p>
<h4 id="二-插入">二、插入</h4>
<p>找到插入位置，并将其设置为<strong>红色</strong>。</p>
<p>接下来若<strong>父节点红色</strong>，才需要平衡操作，否则不需要。</p>
<p>在<strong>父节点红色</strong>的情况下，大体有三种情况需要平衡：</p>
<ol>
<li>父节点的兄弟节点也是红色，将叔父节点和父节点改为黑色，祖父节点改为红色，再对祖父节点平衡</li>
<li>叔父节点为黑色，且父节点和自身都是偏向同一边（左倾或者右倾），交换父节点和祖父节点颜色，对父节点右旋或者左旋，本质是<strong>将节点移动要另一子树</strong>。</li>
<li>叔父节点为黑色，但是父节点和自身偏向不同，左旋或者右旋，得到情况2。</li>
</ol>
<h4 id="三-删除">三、删除</h4>
<p>找到删除节点，同时需要找到一个<strong>替代节点</strong>（删除该节点，同时将该节点数值转移到删除节点，但是颜色不变）。</p>
<ol>
<li>当删除节点不是双子树的情况下，删除该节点（<strong>替代节点即自身</strong>）；</li>
<li>将右子树最小值作为替代节点。</li>
</ol>
<p>若<strong>替代节点黑色</strong>，说明失衡，需要调整。</p>
<p>大体有四种情况，当前节点为<strong>替代节点右子节点</strong>。</p>
<ol>
<li><strong>当前节点红色</strong>，改为黑色；</li>
<li><strong>兄弟节点红色</strong>，左旋或者右旋，将兄弟节点<strong>上升</strong>，使得兄弟节点变为原先兄弟节点的子节点（<strong>必为黑色</strong>），然后转变为3、4其中之一。</li>
<li><strong>兄弟节点黑色</strong>，兄弟节点<strong>子节点都是黑色</strong>，无法通过兄弟子树移动红色节点到自己子树，只能将兄弟节点改为红色，继续递归，直到父节点出现红色，将其变黑。</li>
<li><strong>兄弟节点黑色</strong>，兄弟子节点<strong>其中一个子节点红色</strong>，尝试通过旋转将其<strong>移动</strong>到自己子树，将其变黑，根据子节点情况不同，会旋转一次或者两次。</li>
</ol>
<h4 id="四-查找">四、查找</h4>
<p>二分查找即可。</p>
<p><strong>再会！！！</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[B树]]></title>
        <id>https://zj11224.github.io/post/2022.07.03.B树/</id>
        <link href="https://zj11224.github.io/post/2022.07.03.B树/">
        </link>
        <updated>2022-07-02T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言"><strong>前言</strong></h3>
<p>​	磁盘读取速度慢，本质上是因为磁盘寻址存在物理性操作（磁盘旋转，找到指定位置，然后读取）。这个读取次数是由树高决定的，所以我们需要降低树高，B树应运而生。B树每个节点内存储数据和磁盘块大小相关，这样能充分利用磁盘内部索引。</p>
<p>​	B树比红黑树简单很多！！！</p>
<p>​	红黑树和B/B+树本质上都是2-3-4树的变种，通过上升和下沉操作来保持平衡，只不过在B树中上升和下沉通过分裂和合并实现。</p>
<p>​	B+树是B树变种，中间节点不存数据只存key，只有叶子节点存储数据，同时相邻叶子节点用链表链接，这样范围搜索，只需要找到头节点即可。</p>
<h3 id="开始"><strong>开始</strong></h3>
<h4 id="一-定义">一、定义</h4>
<p>一颗M阶B树T，满足以下条件：</p>
<ol>
<li>每个结点至多拥有M颗子树；</li>
<li>根结点至少拥有两颗子树；</li>
<li>除了根结点以外，其余每个分支结点至少拥有M/2颗子树；</li>
<li>所有的叶结点都在同一层上；</li>
<li>有k颗子树的分支结点则存在k-1个关键字，关键字按照递增顺序进行排序；</li>
<li>关键字数量满足 ceil( M / 2) - 1 &lt;= n &lt;= M - 1。</li>
</ol>
<h4 id="二-数据结构选型">二、数据结构选型</h4>
<p>首先，这是一个平衡树，整体上用多叉树实现。</p>
<p>其次，M选取偶数，key就是奇数个，后面便于分裂。</p>
<p>最后，每个节点内部的数据存储可以用数组或者链表实现。<br>
如果使用链表实现，插入删除O(1)，同时插入删除也伴随查询，查询O(n)。<br>
如果用数组实现，更改头节点O(n)，但是查询（二分查找）时间O(logn)。<br>
B树一般适用于强查询的，所以这里选用数组来实现。</p>
<h4 id="三-插入">三、插入</h4>
<ol>
<li>递归查找到对应位置；</li>
<li>在递归过程中，对下个递归节点，预处理；</li>
<li>下个递归节点如果满了，分裂；</li>
<li>直到找到指定位置，插入。</li>
</ol>
<p>先说下，分裂就是当前节点满了，将其分裂成两个节点，并将中间的数据插入父节点，作为新的两个节点的索引。</p>
<p>这里有两个概念很重要。</p>
<ol>
<li>每次找到的节点，他都是小于 2 * degree - 1，即不满状态。</li>
<li>只插入叶子节点。</li>
</ol>
<p>如何保持不满状态呢？</p>
<p>很简单，预处理 + 分裂。</p>
<p>比如当前位置符合，要往左节点递归，若此时左节点满了，那么就先将左节点分裂，此时父节点会多一个数据，然后才继续递归。</p>
<p>注意根节点满了的特殊情况，要new一个新的根节点，并将第一个索引指向原根节点，然后分裂，递归。</p>
<p>只有创建的第一个节点是叶子节点属性，分裂继承节点属性(这里也会出现新的叶子节点)，但是其他创建的都是普通的节点。</p>
<h4 id="四-删除">四、删除</h4>
<ol>
<li>递归查找到对应位置</li>
<li>在递归过程中，对下个递归节点，预处理</li>
<li>下个递归节点如果恰好为最小数量，尝试借取（有多种情况）</li>
<li>直到找到指定位置，删除</li>
</ol>
<p>这里的逻辑类似插入，就是确保递归进入的节点数据量大于最小值 degree - 1，通过预处理+借取操作实现。</p>
<p>但是这里的借取操作有4种情况：</p>
<ol>
<li>右兄弟节点富裕，自己从父节点借一个，父节点从右兄弟节点借一个；</li>
<li>左兄弟节点富裕，自己从父节点借一个，父节点从左兄弟节点借一个；</li>
<li>左兄弟节点存在，将左兄弟节点、父节点、自己合并；</li>
<li>右兄弟节点存在，将自己、父节点、右兄弟节点合并。</li>
</ol>
<p>删除同样有4种情况：</p>
<ol>
<li>叶子节点数据直接删（注意进入该节点就说明该节点数量大于 degree - 1）;</li>
<li>左孩子富裕，借一个，代替被删除数据（保持删除数据索引有效）；</li>
<li>右孩子富裕，借一个，代替被删除数据（保持删除数据索引有效）；</li>
<li>都不富裕，左孩子、自己、右孩子合并。</li>
</ol>
<h4 id="五-查找">五、查找</h4>
<p>因为用数组实现，所以节点内搜索直接用二分查找即可。</p>
<p><strong>再会！！！</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MapReduce框架]]></title>
        <id>https://zj11224.github.io/post/2022.05.20.MapReduce框架/</id>
        <link href="https://zj11224.github.io/post/2022.05.20.MapReduce框架/">
        </link>
        <updated>2022-05-19T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言"><strong>前言</strong></h3>
<p>MIT6.824课程实验lab1--MapReduce框架</p>
<p>后文的master等同于coordinator</p>
<p>参考：<br>
<a href="https://pdos.csail.mit.edu/6.824/labs/lab-mr.html">官网lab1资料</a><br>
<a href="https://zhuanlan.zhihu.com/p/122571315">MapReduce论文翻译</a><br>
<a href="https://zhuanlan.zhihu.com/p/425093684">MapReduce实验代码、思路</a></p>
<h3 id="开始"><strong>开始</strong></h3>
<h4 id="一-rpc通信">一、rpc通信</h4>
<p>rpc包提供了通过网络或其他I/O连接对一个对象的导出方法的访问。服务端注册一个对象，使它作为一个服务被暴露，服务的名字是该对象的类型名。注册之后，对象的导出方法就可以被远程访问。</p>
<p>因为进程之间需要通信，如work从master领取任务，work告诉master自己任务状态。<br>
这个通信过程我们通过rpc完成。</p>
<h5 id="1-服务端注册监听">1、服务端注册监听</h5>
<pre><code class="language-go">func (c *Coordinator) server() {
    // 注册
    rpc.Register(c)
    // http监听
    rpc.HandleHTTP()
    l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    // 指定监听端口
    go http.Serve(l, nil)
}
</code></pre>
<pre><code class="language-go">// 可以被客户端调用的函数必须符合以下两个条件
// 1、两个参数
// 2、返还值error
func (c *Coordinator) DistributeJob(args, reply *Job) error {}
</code></pre>
<h5 id="2-客户端呼叫服务端">2、客户端呼叫服务端</h5>
<pre><code class="language-go">client, err := rpc.DialHTTP(&quot;tcp&quot;, serverAddress + &quot;:1234&quot;)
if err != nil {
	log.Fatal(&quot;dialing:&quot;, err)
}
</code></pre>
<h5 id="3-客户端调用服务端方法">3、客户端调用服务端方法</h5>
<pre><code class="language-go">var args, reply int
// 参数类型要和服务端函数相同
err = client.Call(&quot;Coordinator.DistributeJob&quot;, args, &amp;reply)
if err != nil {
	log.Fatal(&quot;Coordinator error:&quot;, err)
}
</code></pre>
<h4 id="二-枚举">二、枚举</h4>
<p>![enum](D:\ResourceFile\Documents\My Blog\images\2022.05.20_MapReduce框架\enum.jpg)</p>
<h4 id="三-结构体">三、结构体</h4>
<p>![struct](D:\ResourceFile\Documents\My Blog\images\2022.05.20_MapReduce框架\struct.jpg)</p>
<h4 id="四-关键分配任务逻辑">四、关键分配任务逻辑</h4>
<p>![](D:\ResourceFile\Documents\My Blog\images\2022.05.20_MapReduce框架\distribute.jpg)</p>
<h4 id="五-细节">五、细节</h4>
<ol>
<li>先监听服务再执行channel，不然work无法获得任务（本质是channel堵塞无法往下执行）。</li>
<li>channel默认一个缓存，当里面的数据没有被接收时会堵塞。<br>
以为创建发送任务和接收任务并发执行，所以建议初始化channel缓存长度大于任务数。</li>
<li>shell脚本循环执行命令，只有上一条命令完成时，才会执行下一条命令，不是并发执行。<br>
想要并发执行，命令后面添加&amp;（后台同时执行）。</li>
<li>rpc中Call，参数必须实例化！！！</li>
</ol>
<h4 id="五-完善">五、完善</h4>
<p>目前只基本实现了功能，后面的crash.go的随机kill和延迟还没有解决。<br>
而且是参照大佬的实验步骤，所以部分细节还是有一些迷糊。</p>
<p>因为后面的raft大作业需要用到，先到lab2学习。</p>
<hr>
<p>所有的实验步骤到此结束，<strong>再会！！！</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ubuntu vsftpd远程配置]]></title>
        <id>https://zj11224.github.io/post/2022.05.05.Ubuntu vsftpd远程配置/</id>
        <link href="https://zj11224.github.io/post/2022.05.05.Ubuntu vsftpd远程配置/">
        </link>
        <updated>2022-05-04T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言"><strong>前言</strong></h3>
<p>记录个人ubuntu16.04中vsftpd服务的配置。</p>
<p>配置结束后，部分cmd命令无法远程，但是可以通过资源管理器地址栏登录，就可以上传下载文件。</p>
<h3 id="开始"><strong>开始</strong></h3>
<h4 id="一-安装vsftpd服务">一、安装vsftpd服务</h4>
<pre><code class="language-shell"># 安装vsftpd
sudo apt-get install vsftpd
sudo service vsftpd start|stop|restart
# 服务自启动
sudo systemctl start vsftpd.service
# 连接端口为21，通过查看端口21是否监听，可看出ftp服务是否启动
sudo netstat -nltp | grep 21
</code></pre>
<h4 id="二-创建本地用户">二、创建本地用户</h4>
<pre><code class="language-shell">sudo mkdir /home/ftp
# 添加用户，-d指定用户目录，-s指定用户登录终端
sudo useradd -d /home/ftp -s /bin/bash ftp	
# 仅通过ftp登录
sudo usermod -s /sbin/nologin ftp
# 设置密码
sudo passwd ftp
	password
# 设置/home/ftp文件夹拥有者为ftp，使用者group为ftp
sudo chown ftp:ftp /home/ftp
</code></pre>
<h4 id="三-虚拟用户创建可跳过">三、虚拟用户创建（可跳过）</h4>
<pre><code class="language-shell"># 创建user.txt，文本格式为一行username，一行password
vim user.txt
	username1
	password1
	username2
	password2
	...

# 安装生成数据库文件的软件
sudo apt-get install db-util
# 将虚拟用户文件加密
sudo db_load -T -t hash -f /home/user.txt /etc/vsftpd_login.db
sudo chmod 600 /etc/vsftpd_login.db

# 存在bug，不能配置该文件，删掉
sudo rm /etc/pam.d/vsftpd
# 虚拟用户登录文件配置
vim /etc/pam.d/vsftpd.vu
	auth required pam_userdb.so db=/etc/vsftpd_login
	account required pam_userdb.so db=/etc/vsftpd_login
</code></pre>
<h4 id="四-设置文件基本配置">四、设置文件基本配置</h4>
<pre><code class="language-shell"># 编辑vsftpd配置文件
sudo vim /etc/vsftpd.conf
	listen=NO
	listen_ipv6=YES
	# 匿名
	anonymous_enable=YES|NO		
	# 本地
	local_enable=YES|NO		
    # 虚拟
	guest_enable=YES|NO
    # 虚拟用户所使用用户
	guest_username=ftp
	# 虚拟用户数据库文件路径，文件在/etc/pam.d/
	pam_service_name=vsftpd.vu	
	
	# 用户访问列表是否启用
	userlist_enable=YES|NO				
	userlist_file=/etc/vsftpd/vsftpd.user_list
	# YES:黑名单,NO:白名单
	userlist_deny=NO					
	
	# 禁止访问ftp根目录以外路径
    chroot_local_user=YES
    # 是否开启白名单
	chroot_list_enable=YES
    # 白名单
	chroot_list_file=/etc/vsftpd/vsftpd.chroot_list
	# 开启写模式
	allow_writeable_chroot=YES					
	
	# 用户各自配置文件夹
	user_config_dir=/etc/vsftpd/vsftpd_user_conf	
	
	# 开启ip访问控制列表，配置文件在/etc/hosts.allow|hosts.deny
	tcp_wrappers=YES
	
	# 默认配置 #
	local_mask=022
	dirmessage_enable=YES
	xferlog_enable=YES
	connect_from_port_20=YES
</code></pre>
<h4 id="五-各类文件配置格式">五、各类文件配置格式</h4>
<pre><code class="language-shell"># 用户访问其他路径控制列表
sudo vim /etc/vsftpd/vsftpd.chroot_list
	username1
	username2
	...

# 用户配置列表文件夹
sudo mkdir /etc/vsftpd/vsftpd_user_conf
# 更改对应用户名文件
vim /etc/vsftpd/vsftpd_user_conf/ftp
	# 禁止删除命令
	cmds_denied=DELE			
	...

# 用户访问vsftpd控制列表
sudo vim /etc/vsftpd.user_list			
	username1
	username2
	...

# ip访问vsftpd控制列表
sudo vim /etc/hosts.allow
	# vsftpd:ALL
	vsftpd:192.168.5.0/255.255.255.0
	...
sudo vim /etc/hosts.deny
	...
</code></pre>
<h4 id="六-用户各自配置文件">六、用户各自配置文件</h4>
<pre><code class="language-shell"># 用户各自配置文件
vim /etc/vsftpd_user_conf/username
	# 设置根目录
	local_root=/home/ftp
	
	# 开启上传文件所属更改
	chown_uploads=YES
	# 文件所属ftp用户
	chown_username=ftp	
	
	# 具体参数参考这篇博客 #
	# https://www.cnblogs.com/ssrs-wanghao/articles/13751408.html #
    write_enable=YES
    anon_world_readable_only=NO 
    anon_upload_enable=YES 
    anon_mkdir_write_enable=YES
    anon_other_write_enable=YES
</code></pre>
<h4 id="七-遇到的问题">七、遇到的问题</h4>
<p>这里说几个我遇到的错误代码：</p>
<p>500：如果用户被限定在了其主目录下，则该用户的主目录不能再具有写权限了！如果检查发现还		有写权限，就会报该错误。<br>
去除主目录的写权限：<code>$ sudo chmod a-w /home/user</code><br>
或者配置文件添加：<code>allow_writeable_chroot=YES</code></p>
<p>550/425：未解决，初步推测是网络传输和端口控制的问题（但是我服务机并没有防火墙服务）。</p>
<p>但若通过资源管理器的地址栏登录，可以直接复制粘贴文件，以上问题就不会出现。</p>
<p>所有的配置到此结束，<strong>再会！！！</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Ubuntu Go环境配置]]></title>
        <id>https://zj11224.github.io/post/2022.04.26.Ubuntu Go环境配置/</id>
        <link href="https://zj11224.github.io/post/2022.04.26.Ubuntu Go环境配置/">
        </link>
        <updated>2022-04-25T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言"><strong>前言</strong></h3>
<p>简单记录下，linux下go环境配置的坑。</p>
<h3 id="开始"><strong>开始</strong></h3>
<h4 id="一-下载go安装包">一、下载GO安装包</h4>
<p>可以通过命令行下载（需要国内源）：<br>
<code>sudo apt-get install go</code><br>
但是这样无法选定安装路径，而且版本可能会过低，不推荐。</p>
<p>这里建议通过wget方式安装<br>
下载（国内镜像站）： https://studygolang.com/dl/golang/go1.15.linux-amd64.tar.gz<br>
解压：<code>sudo tar -C /usr/local -zxvf go1.15.linux-amd64.tar.gz</code></p>
<h4 id="二-配置环境变量">二、配置环境变量</h4>
<p>先打开环境变量配置文件<br>
<code>sudo vim ~/.bashrc</code></p>
<p>这里推荐<code>~/.bashrc</code><br>
因为之前尝试配置<code>/etc/profile</code>和<code>~/.profile</code>都出现过<strong>重开机后需要手动刷新</strong>的情况，非常奇怪<br>
这里推荐home目录下的<code>./bashrc</code></p>
<p>添加以下三行配置并保存退出</p>
<pre><code class="language-shell">#go解压位置
export GOROOT=/usr/local/go
#开发者目录
export GOPATH=/home/username/go
export PATH=$PATH:$GOROOT/bin:$GOPATH/bin
</code></pre>
<p>通过下面命令刷新，或者重启<br>
<code>source ~/.bashrc</code></p>
<h4 id="三-go-module设置">三、GO MODULE设置</h4>
<p>运行<code>go version</code><br>
若出现<code>go version go1.15 linux/amd64</code><br>
则说明配置成功</p>
<p>通过<code>go env</code>查看go的详细信息<br>
通过<code>go env -w GO111MODULE=on</code> 将GO111MODULE设置为开始，若已经启用，跳过<br>
通过<code>go env -w GOPROXY=https://goproxy.cn,direct</code> 将代理设置为国内源方便后面git clone</p>
<p>在你的工程文件夹下，输入以下命令<br>
<code>go mod init xxx</code><br>
xxx为你的项目名，不一定要和工程文件夹名相同</p>
<p>但是后面你的导入自己的包就要用到这个module名<br>
比如：<code>import xxx/packageName</code></p>
<p>所有的配置到此结束，<strong>再会！！！</strong></p>
]]></content>
    </entry>
</feed>